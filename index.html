<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Performance tricks I learned from contributing to the Azure .NET SDK</title>
	<meta name="author" content="Daniel Marbach">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="dist/custom.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-background="img/juggler-trick-magician-juggle-1216853.jpg">
				<div style="left: 10; width: 52%; padding: 25px; font-size: 30px; text-align: left;">
					<h3 style="text-transform: none;color: rgba(31, 129, 74, 0.9);">Performance tricks I learned from
						contributing to the Azure .NET SDK</h3>
					<p style="text-transform: none;color: rgba(31, 129, 74, 0.6); font-size: small;">
						<i class="fa fa-twitter" aria-hidden="true"><a
								style="text-transform: none;color: rgba(31, 129, 74, 0.6)"
								href="https://twitter.com/danielmarbach"> danielmarbach</a> |</i>
						<i class="fa fa-envelope" aria-hidden="true"> <a
								style="text-transform: none;color: rgba(31, 129, 74, 0.6)"
								href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#100;&#97;&#110;&#105;&#101;&#108;&#46;&#109;&#97;&#114;&#98;&#97;&#99;&#104;&#64;&#111;&#112;&#101;&#110;&#112;&#108;&#97;&#99;&#101;&#46;&#110;&#101;&#116;">&#100;&#97;&#110;&#105;&#101;&#108;&#46;&#109;&#97;&#114;&#98;&#97;&#99;&#104;&#64;&#111;&#112;&#101;&#110;&#112;&#108;&#97;&#99;&#101;&#46;&#110;&#101;&#116;</a></i>
					</p>
				</div>
			</section>
			<section>
				<section data-background="img/architecture-g104d6d62d_1280.jpg">
					<div class="image-slide-box">
						<h2>Introduction</h2>
						<p>Focus on performance optimization in .NET Code and not architecture.</p>
					</div>
					<aside class="notes">
						<ul>
							<li>Not about horizontal and vertical scaling</li>
							<li>.NET has been evolving over the years into a modern and high-performance platform.</li>
							<li>C/C++ is less and less needed</li>
						</ul>
					</aside>
				</section>
				<section data-background="img/tarot-g4ac5fb817_1280.jpg">
					<div class="image-slide-box">
						<h2>Esoteric</h2>
						<p>Being called out for premature optimizations.</p>
					</div>
					<aside class="notes">
						<ul>
							<li>Don't jump to conclusions and apply them blindly.</li>
							<li>Code executed under scale it matters: More efficient in resource usage, execution time,
								throughput and memory usage</li>
							<li>But what does at scale even mean? How can I find out whether the optimizations I'm
								trying to make have value, and I'm not getting called out by my colleagues for premature
								optimizations?</li>
						</ul>
					</aside>
				</section>
			</section>
			<section data-background="img/animal-3346192_1280.jpg">
				<div
					style="left: 10; width: 35%; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: left;">
					<h5>At Scale implementation details matter</h5>
					<div style="font-style: italic;">
						<p>&ldquo;Scale for an application can mean the number of users that will concurrently connect
							to the application at any given time, the amount of input to process or the number of times
							data needs to be processed.</p>
						<p>For us, as engineers, it means we have to know <b>what to ignore</b> and knowing <b>what to
								pay close attention to</b>.&rdquo; <a
								href="https://speakerdeck.com/davidfowl/implementation-details-matter">David Fowler</a>
						</p>
					</div>
				</div>
				<aside class="notes">
					<ul>
						<li>Discover the assumptions that have accumulated over time</li>
						<li>Pay close attention to what is instantiated, parsed, processed etc. per request</li>
						<li>How those assumptions in the code base affect the performance characteristics (memory,
							throughput...) at scale</li>
					</ul>
				</aside>
			</section>
			<section>
				<section data-background-video="vids/Give-me-the-code-natalia.mp4">
				</section>
				<section data-auto-animate>
					<ul>
						<li data-id="allocations">Avoid excessive allocations to reduce the GC overhead</li>
						<li data-id="copying">Avoid unnecessary copying of memory</li>
					</ul>
					<h2 class="r-fit-text" data-id="thumb">Rules of thumb</h2>
				</section>
				<section data-auto-animate>
					<ul class="r-fit-text">
						<li data-id="allocations">Avoid excessive allocations to reduce the GC overhead</li>
						<ul>
							<li class="fragment fade-in">Be aware of closure allocations</li>
							<li class="fragment fade-in">Be aware of parameter overloads</li>
							<li class="fragment fade-in">Where possible and feasible use value types <br />but pay
								attention to unnecessary boxing</li>
							<li class="fragment fade-in">Think at least twice before using LINQ <br /> or
								unnecessary enumeration on the hot path</li>
							<li class="fragment fade-in">Pool and re-use buffers</li>
							<li class="fragment fade-in">For smaller local buffers, consider using the stack</li>
						</ul>
						<li data-id="copying">Avoid unnecessary copying of memory
							<ul>
								<li class="fragment fade-in">Watch out for immutable/readonly data that is copied</li>
								<li class="fragment fade-in">Look for Stream and Byte-Array usages that are copied or
									manipulated without using
									<code>Span</code> or <code>Memory</code>
								</li>
								<li class="fragment fade-in">Replace existing data manipulation methods with newer
									<code>Span</code> or
									<code>Memory</code> based variants
								</li>
							</ul>
						</li>
					</ul>
				</section>
			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Think at least twice before using LINQ or unnecessary enumeration on the hot path</p>
					</div>
					<aside class="notes">
						LINQ is great, and I wouldn't want to miss it at all. Yet, on the hot path it is far too easy to
						get into troubles with LINQ because it can cause hidden allocations and is difficult for the JIT
						to optimize. Let's look at a piece of code from the AmqpReceiver
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|8|10|11" data-trim data-noescape><script type="text/template">
							public class AmqpReceiver {
								
								ConcurrentBag<Guid> _lockedMessages = new ();
								
								public Task CompleteAsync(IEnumerable<string> lockTokens) 
									=> CompleteInternalAsync(lockTokens);
								
								Task CompleteInternalAsync(IEnumerable<string> lockTokens) 
								{
									Guid[] lockTokenGuids = lockTokens.Select(token => new Guid(token)).ToArray();
									if (lockTokenGuids.Any(lockToken => _lockedMessages.Contains(lockToken))) 
									{
									  // do special path accessing lockTokenGuids
									  return Task.CompletedTask;
									}
									// do normal path accessing lockTokenGuids
									return Task.CompletedTask;
								}
							}
						</script></code></pre>
					<aside class="notes">
						<ul>
							<li>Explain AmqpReceiver</li>
							<li>Enumerable, string to guid, Any with contains</li>
							<li>Decompile</li>
						</ul>
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|8-9|10,17" data-trim data-noescape><script type="text/template">
							public class AmqpReceiver {
	
								// ...
								// Compiler generated chunk we are not really interested in right now
	
								private Task CompleteInternalAsync(IEnumerable<string> lockTokens)
								{
									Enumerable.Any(Enumerable.ToArray(Enumerable.Select(lockTokens, <>c.<>9__2_0 ?? 
										(<>c.<>9__2_0 = new Func<string, Guid>(<>c.<>9.<CompleteInternalAsync>b__2_0)))), 
											new Func<Guid, bool>(<CompleteInternalAsync>b__2_1));
									return Task.CompletedTask;
								}
							
								[CompilerGenerated]
								private bool <CompleteInternalAsync>b__2_1(Guid lockToken)
								{
									return Enumerable.Contains(_lockedMessages, lockToken);
								}
							}
						</script></code></pre>
					<aside class="notes">
						For every call of CompleteInternalAsync a new instance of Func&lt;Guid, bool&gt; is allocated
						that points to &lt;CompleteInternalAsync&gtb__2_1. A closure captures the _lockedMessages and
						the lockToken as state.<br />
						It is possible to simply turn the Any into a loop.
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens) 
							=> CompleteInternalAsync(lockTokens);

						Task CompleteInternalAsync(IEnumerable<string> lockTokens) 
						{
							Guid[] lockTokenGuids = lockTokens.Select(token => new Guid(token)).ToArray();
							foreach (var tokenGuid in lockTokenGuids) 
							{
								if (_requestResponseLockedMessages.Contains(tokenGuid))
								{
									return Task.CompletedTask;
								}
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|6-8" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens) 
							=> CompleteInternalAsync(lockTokens);

						Task CompleteInternalAsync(IEnumerable<string> lockTokens) 
						{
							Guid[] array = Enumerable.ToArray(Enumerable.Select(lockTokens, 
								<>c.<>9__2_0 ?? 
								(<>c.<>9__2_0 = new Func<string, Guid>(<>c.<>9.<CompleteInternalAsync>b__2_0))));

							int num = 0;
							while (num < array.Length)
							{
								Guid item = array[num];
								if (_requestResponseLockedMessages.Contains(item))
								{
									return Task.CompletedTask;
								}
								num++;
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section>
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:35%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~20-40%<br />
								<i class="fa fa-trash-o"></i> ~20-40%
							</p>
						</div>
						<img src="benchmarks/LinqBeforeAfterComparisonCropped.png" />
					</div>
					<aside class="notes">
						By getting rid of the Any we were able to squeeze out some good performance improvements.
						Sometimes, though, we can do even more. For example, there are a few general rules we can follow
						when we refactor a code path using LINQ to collection-based operations.
					</aside>
				</section>
				<section>
					<h2 class="r-fit-text" data-id="thumb">LINQ to collection-based operations</h2>
					<ul>
						<li class="fragment fade-in">Use <code>Array.Empty&lt;T&gt;</code> to represent empty arrays
						</li>
						<li class="fragment fade-in">Use <code>Enumerable.Empty&lt;T&gt;</code> to represent empty
							enumerables</li>
						<li class="fragment fade-in">Prevent collections from growing</li>
						<li class="fragment fade-in">Use concrete collection types</li>
						<li class="fragment fade-in">Leverage pattern matching or
							<code>Enumerable.TryGetNonEnumeratedCount</code>
						</li>
					</ul>
					<aside class="notes">
						Going back to the previous example that we have optimized already quite a bit, let's see how we
						can apply those principles we learned above to the code. As a reminder here is how the code
						looks like.
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|6" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens) 
							=> CompleteInternalAsync(lockTokens);

						Task CompleteInternalAsync(IEnumerable<string> lockTokens) 
						{
							Guid[] lockTokenGuids = lockTokens.Select(token => new Guid(token)).ToArray();
							foreach (var tokenGuid in lockTokenGuids) 
							{
								if (_requestResponseLockedMessages.Contains(tokenGuid))
								{
									return Task.CompletedTask;
								}
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|2-6|10|12-13|17-18" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens) {
							IReadOnlyCollection<string> readOnlyCollection = lockTokens switch
							{
								IReadOnlyCollection<string> asReadOnlyCollection => asReadOnlyCollection,
								_ => lockTokens.ToArray(),
							};
							return CompleteInternalAsync(readOnlyCollection);
						}
						
						Task CompleteInternalAsync(IReadOnlyCollection<string> lockTokens)
						{
							int count = lockTokens.Count;
							Guid[] lockTokenGuids = count == 0 ? Array.Empty<Guid>() : new Guid[count];
							int index = 0;
							foreach (var token in lockTokens)
							{
								var tokenGuid = new Guid(token);
								lockTokenGuids[index++] = tokenGuid;
								if (_requestResponseLockedMessages.Contains(tokenGuid))
								{
									return Task.CompletedTask;
								}
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
					<aside class="notes">
						TBD
					</aside>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section>
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:35%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(155, 168, 33, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~5-64% (worst +56%)<br />
								<i class="fa fa-trash-o"></i> ~23-61%
							</p>
						</div>
						<img src="benchmarks/LinqAfterComparisonCropped.png" />
					</div>
					<aside class="notes">
						<ul>
							<li>Lazy enumeration is much worse.</li>
							<li> Is that an indication we shouldn't be doing such a refactoring?</li>
							<li>Well it depends</li>
							<li>Like with all things, it is crucial to know when to stop on a given code path and find
								other areas that are more impactful to optimize. The context of the piece of code that
								you are trying to optimize is key.</li>
						</ul>
					</aside>
				</section>
			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Be aware of closure allocations</p>
					</div>
					<aside class="notes">
						We have already touched a bit on closure allocations during our LINQ performance investigations.
						But closures can occur anywhere where we have lambdas (Action or Func delegates) being invoked
						that access state from the outside of the lambda.
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="|1|2|13" data-trim data-noescape><script type="text/template">
						async Task RunOperation(
							Func<TimeSpan, Task> operation, 
							TransportConnectionScope scope, CancellationToken cancellationToken) 
						{
							TimeSpan tryTimeout = CalculateTryTimeout(0);
							// omitted
							while (!cancellationToken.IsCancellationRequested) {
								if (IsServerBusy) {
									await Task.Delay(ServerBusyBaseSleepTime, cancellationToken);
								}
						
								try	{
									await operation(tryTimeout);
									return;
								}
								catch {
									// omitted
								}
							}
						}
						</script></code></pre>
				</section>
				<section>
					<pre class="" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="|1,4-5" data-trim data-noescape><script type="text/template">
						TransportMessageBatch messageBatch = null;
						Task createBatchTask = _retryPolicy.RunOperation(async (timeout) =>
						{
							messageBatch = 
								await CreateMessageBatchInternalAsync(options, timeout);
						},
						_connectionScope,
						cancellationToken);
						await createBatchTask;
						return messageBatch;
						</script></code></pre>
				</section>
				<section>
					<pre class="" style="font-size: 0.43em"><code class="language-csharp" data-line-numbers="|2,8" data-trim data-noescape><script type="text/template">
						if (num1 != 0)	{
							this.\u003C\u003E8__1 = new AmqpSender.\u003C\u003Ec__DisplayClass16_0();
							this.\u003C\u003E8__1.\u003C\u003E4__this = this.\u003C\u003E4__this;
							this.\u003C\u003E8__1.options = this.options;
							this.\u003C\u003E8__1.messageBatch = (TransportMessageBatch) null;

							configuredTaskAwaiter = amqpSender._retryPolicy.RunOperation(
								new Func<TimeSpan, Task>((object) this.\u003C\u003E8__1,
									 __methodptr(\u003CCreateMessageBatchAsync\u003Eb__0)), 
									 (TransportConnectionScope) amqpSender._connectionScope, 
									 this.cancellationToken).ConfigureAwait(false).GetAwaiter();

							// rest omitted
						}
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.45em"><code class="language-csharp" data-line-numbers="|1|2,3|14" data-trim data-noescape><script type="text/template">
						internal async ValueTask<TResult> RunOperation<T1, TResult>(
							Func<T1, TimeSpan, CancellationToken, ValueTask<TResult>> operation,
							T1 t1,
							TransportConnectionScope scope,
							CancellationToken cancellationToken) {
							TimeSpan tryTimeout = CalculateTryTimeout(0);
							// omitted
							while (!cancellationToken.IsCancellationRequested) {
								if (IsServerBusy) {
									await Task.Delay(ServerBusyBaseSleepTime, cancellationToken);
								}
						
								try	{
									return await operation(t1, tryTimeout, cancellationToken);
								}
								catch {
									// omitted
								}
							}
						}
						</script></code></pre>
				</section>
				<section>
					<pre class="" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="|1|2,3|6,8,9,12" data-trim data-noescape><script type="text/template">
						internal async ValueTask RunOperation<T1>(
							Func<T1, TimeSpan, CancellationToken, ValueTask> operation,
							T1 t1,
							TransportConnectionScope scope,
							CancellationToken cancellationToken) =>
								await RunOperation(static async (value, timeout, token) =>
								{
									var (t1, operation) = value;
									await operation(t1, timeout, token);
									return default(object);
								}, 
							(t1, operation),
							scope, cancellationToken);
						</script></code></pre>
				</section>
				<section>
					<pre class="" style="font-size: 0.3em"><code class="language-csharp" data-line-numbers="|4,9" data-trim data-noescape><script type="text/template">
						if (num1 != 0) {
							configuredTaskAwaiter = t1._retryPolicy
								.RunOperation<AmqpSender, CreateMessageBatchOptions, TransportMessageBatch>(
								AmqpSender.\u003C\u003Ec.\u003C\u003E9__16_0 ?? (AmqpSender.\u003C\u003Ec.\u003C\u003E9__16_0 = 
									new Func<AmqpSender, CreateMessageBatchOptions, TimeSpan, CancellationToken, Task<TransportMessageBatch>>(
										(object) AmqpSender.\u003C\u003Ec.\u003C\u003E9, 
										__methodptr(\u003CCreateMessageBatchAsync\u003Eb__16_0))), 
										t1, 
										this.options, 
										(TransportConnectionScope) t1._connectionScope, 
										this.cancellationToken).ConfigureAwait(false).GetAwaiter();
							// rest omitted
						}
						</script></code></pre>
					<aside class="notes">
						With that small change, we save the display class and the function delegate allocations and can
						properly usage methods that support value tasks without having to allocate a task instance when
						not necessary.
						To demonstrate how these can add up in real-world scenarios, let me show you a before and after
						comparison when I removed the closure allocations for NServiceBus pipeline execution
					</aside>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section>
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:20%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~74-78%<br />
								<i class="fa fa-trash-o"></i> ~Gone!
							</p>
						</div>
						<img src="benchmarks/NServiceBusPipelineExecutionCropped.png" />
					</div>
				</section>
				<section>
					<h2 class="r-fit-text" data-id="thumb">How to detect those allocations?</h2>
					<ul>
						<li class="fragment fade-in">Use memory profilers and watch out for excessive allocations of
							<code>*__DisplayClass*</code> or various variants of <code>Action*</code> and
							<code>Func*</code>
						</li>
						<li class="fragment fade-in">Use tools like <a
								href="https://plugins.jetbrains.com/plugin/9223-heap-allocations-viewer">Heap Allocation
								Viewer (Rider)</a> or <a
								href="https://marketplace.visualstudio.com/items?itemName=MukulSabharwal.ClrHeapAllocationAnalyzer">Heap
								Allocation Analyzer (Visual Studio)</a></li>
						<li class="fragment fade-in">Many built-in .NET types that use delegates have nowadays generic
							overloads that allow to pass state into the delegate.</li>
					</ul>
				</section>
				<section>
					<pre style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						var someState1 = new object();
						var someOtherState = 42;
						
						var dictionary = new ConcurrentDictionary<string, string>();
						
						dictionary.GetOrAdd("SomeKey", static (key, state) => {
							var (someState, someOtherState) = state;
						
							return $"{someState}_{someOtherState}";
						}, (someState1, someOtherState));
						</script></code></pre>
				</section>
			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div
						style="margin-left: auto; margin-right: auto; width: 60%; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: left;">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Pool and re-use buffers (and larger objects)</p>
					</div>
				</section>
				<section>
					<pre style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="|3,4" data-trim data-noescape><script type="text/template">
						var data = new ArraySegment<byte>(Guid.NewGuid().ToByteArray());

						var guidBuffer = new byte[16];
						Buffer.BlockCopy(data.Array, data.Offset, guidBuffer, 0, 16);
						var lockTokenGuid = new Guid(guidBuffer);
						</script></code></pre>
				</section>
				<section>
					<pre style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="|1|4" data-trim data-noescape><script type="text/template">
						byte[] guidBuffer =  ArrayPool<byte>.Shared.Rent(16);
						Buffer.BlockCopy(data.Array, data.Offset, guidBuffer, 0, 16);
						var lockTokenGuid = new Guid(guidBuffer);
						ArrayPool<byte>.Shared.Return(guidBuffer);
						</script></code></pre>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section>
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:-10%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(168, 114, 33, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> +226%<br />
								<i class="fa fa-trash-o"></i> ~Gone!
							</p>
						</div>
						<img src="benchmarks/BufferAndBlockCopyPooling.png" />
					</div>
				</section>
				<section>
					<pre><code class="language-csharp" data-line-numbers="|1|2" data-trim data-noescape><script type="text/template">
						Span<byte> guidBytes = stackalloc byte[16];
						data.AsSpan().CopyTo(guidBytes);
						var lockTokenGuid = new Guid(guidBytes);
						</script></code></pre>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section>
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:-10%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~45%<br />
								<i class="fa fa-trash-o"></i> ~Gone!
							</p>
						</div>
						<img src="benchmarks/StackallocWithGuid.png" />
					</div>
				</section>
			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Parameter overloads and boxing</p>
					</div>
					<aside class="notes">
						Some methods have parameter overloads of type `params object[]`. That can lead to some sneaky
						and costly array allocations that you might not even be aware of. With never incarnations of
						.NET there have been a number of improvements done on that area by introducing new method
						overloads for common cases that don't require to allocate a parameter array.
					</aside>
				</section>
				<section data-auto-animate>
					<code data-id="whenany-title">Task.WhenAny</code>
					<pre data-id="whenany"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						public static Task<Task> WhenAny(params Task[] tasks);
						// most common case
						await Task.WhenAny(new[] { task1, task2 });	
						</script></code></pre>
				</section>
				<section data-auto-animate>
					<code data-id="whenany-title">Task.WhenAny</code>
					<pre data-id="whenany"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						public static Task<Task> WhenAny(Task task1, Task task2);
							
						await Task.WhenAny(task1, task2);	
						</script></code></pre>
				</section>
				<section data-auto-animate>
					<code>CancellationTokenSource</code>
					<pre data-id="tokensource" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						public static CancellationTokenSource CreateLinkedTokenSource(
							params CancellationToken[] tokens
						);
						</script></code></pre>
				</section>
				<section data-auto-animate>
					<code>CancellationTokenSource</code>
					<pre data-id="tokensource" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						public static CancellationTokenSource CreateLinkedTokenSource(
							CancellationToken token1,
							CancellationToken token2
						);
						</script></code></pre>
				</section>
			</section>
			<section>
				<section data-background="img/plotter-2138990_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid unnecessary copying of memory</h2>
					</div>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<ul>
						<li class="fragment fade-in">Watch out for immutable/readonly data that is copied</li>
						<li class="fragment fade-in">Look for Stream and Byte-Array usages that are copied or
							manipulated without using
							<code>Span</code> or <code>Memory</code>
						</li>
						<li class="fragment fade-in">Replace existing data manipulation methods with newer
							<code>Span</code> or
							<code>Memory</code> based variants
						</li>
					</ul>
				</section>
				<section data-auto-animate>
					<pre data-id="body-copy" style="font-size: 0.45em"><code class="language-csharp" data-line-numbers="|11-12" data-trim data-noescape><script type="text/template">
						public class ServiceBusReceivedMessage {
							public BinaryData Body { get; }
						}
						
						public static ServiceBusMessage 
							CreateFrom(ServiceBusReceivedMessage message) {
							//...
							var originalBody = message.Body;
							if (!originalBody.IsEmpty)
							{
								var clonedBody = new byte[originalBody.Length];
								Array.Copy(originalBody.ToArray(), clonedBody, originalBody.Length);
								copiedMessage.Body = clonedBody;
							}
						}
						</script></code></pre>
				</section>
				<section data-auto-animate>
					<pre data-id="body-copy" style="font-size: 0.45em"><code class="language-csharp" data-line-numbers="|11" data-trim data-noescape><script type="text/template">
						public class ServiceBusReceivedMessage {
							public BinaryData Body { get; }
						}
						
						public static ServiceBusMessage 
							CreateFrom(ServiceBusReceivedMessage message) {
							//...
							var originalBody = message.Body;
							if (!originalBody.IsEmpty)
							{
								copiedMessage.Body = originalBody;
							}
						}
						</script></code></pre>
					<aside class="notes">
						Other times memory copying isn't so obvious or requires a deep understand of what is happening
						under the hoods of the framework, library or SDK in use.
					</aside>
				</section>
				<section>
					<pre class="stretch" data-id="compute-hash" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|11" data-trim data-noescape><script type="text/template">
						private static short GenerateHashCode(string partitionKey) {
							if (partitionKey == null) {
								return 0;
							}
						
							var encoding = Encoding.UTF8;
							ComputeHash(encoding.GetBytes(partitionKey), 0, 0, out uint hash1, out uint hash2);
							return (short)(hash1 ^ hash2);
						}
						
						private static void ComputeHash(byte[] data, uint seed1, uint seed2, 
							out uint hash1, out uint hash2)	{

							uint a, b, c;
						
							a = b = c = (uint)(0xdeadbeef + data.Length + seed1);
							c += seed2;
						
							int index = 0, size = data.Length;
							while (size > 12) {
								a += BitConverter.ToUInt32(data, index);
								b += BitConverter.ToUInt32(data, index + 4);
								c += BitConverter.ToUInt32(data, index + 8);
						
							// rest omitted
						}
						</script></code></pre>
					<aside class="notes">
						Other times memory copying isn't so obvious or requires a deep understand of what is happening
						under the hoods of the framework, library or SDK in use.
					</aside>
				</section>
				<section>
					<pre class="stretch" data-id="compute-hash" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|10|7,14-16|18-19|16,23-25|29|1,15" data-trim data-noescape><script type="text/template">
						[SkipLocalsInit]
						private static short GenerateHashCode(string partitionKey) {
							if (partitionKey == null) {
								return 0;
							}
						
							const int MaxStackLimit = 256;
						
							byte[] sharedBuffer = null;
							var partitionKeySpan = partitionKey.AsSpan();
							var encoding = Encoding.UTF8;
						
							var partitionKeyByteLength = encoding.GetMaxByteCount(partitionKey.Length);
							var hashBuffer = partitionKeyByteLength <= MaxStackLimit ?
								stackalloc byte[MaxStackLimit] :
								sharedBuffer = ArrayPool<byte>.Shared.Rent(partitionKeyByteLength);
						
							var written = encoding.GetBytes(partitionKeySpan, hashBuffer);
							var slicedBuffer = hashBuffer.Slice(0, written);

							ComputeHash(slicedBuffer, 0, 0, out uint hash1, out uint hash2);

							if (sharedBuffer != null) {
								ArrayPool<byte>.Shared.Return(sharedBuffer);
							}
							return (short)(hash1 ^ hash2);
						}

						private static void ComputeHash(ReadonlySpan<byte> data, uint seed1, uint seed2, 
							out uint hash1, out uint hash2)	{
							// rest omitted
						}
						</script></code></pre>
					<aside class="notes">
						TBD
					</aside>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section>
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:17%; top:35%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~38-47%<br />
								<i class="fa fa-trash-o"></i> ~Gone!
							</p>
						</div>
						<img src="benchmarks/PartitionKeyResolver.png" />
					</div>
				</section>
				<section>
					<ul class="r-fit-text">
						<li>Avoid excessive allocations to reduce the GC overhead</li>
						<ul>
							<li>Be aware of closure allocations</li>
							<li>Be aware of parameter overloads</li>
							<li>Where possible and feasible use value types <br />but pay
								attention to unnecessary boxing</li>
							<li>Think at least twice before using LINQ <br /> or
								unnecessary enumeration on the hot path</li>
							<ul>
								<li>Use <code>Array.Empty&lt;T&gt;</code> to represent empty arrays
								</li>
								<li>Use <code>Enumerable.Empty&lt;T&gt;</code> to represent empty
									enumerables</li>
								<li>Prevent collections from growing</li>
								<li>Use concrete collection types</li>
								<li>Leverage pattern matching or
									<code>Enumerable.TryGetNonEnumeratedCount</code>
								</li>
							</ul>
							<li>Pool and re-use buffers</li>
							<li>For smaller local buffers, consider using the stack</li>
						</ul>
						<li>Avoid unnecessary copying of memory
							<ul>
								<li>Watch out for immutable/readonly data that is copied</li>
								<li>Look for Stream and Byte-Array usages that are copied or manipulated without using
									<code>Span</code> or <code>Memory</code>
								</li>
								<li>Replace existing data manipulation methods with newer <code>Span</code> or
									<code>Memory</code> based variants
								</li>
							</ul>
						</li>
					</ul>
				</section>
				<section data-background="img/quiz-2137664_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">In case you are up for a challenge</h2>
						<p>The original ComputeHash method had a bug... Did you spot it?</p>
					</div>
					<aside class="notes">
					</aside>
				</section>
				<section data-background="img/science-1182713_1280.jpg">
					<div
						style="width: 70%; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.8); color: rgb(255, 255, 255); padding: 25px; font-size: 25px; text-align: left;">
						<h5>At Scale implementation details matter</h5>
						<div>
							<p>Sometimes that will mean ignoring the performance optimizations learned here in the code
								bases they don't matter, yet consistently applying them where they do</p>
							<p><a
									href="github.com/danielmarbach/PerformanceTricksAzureSDK">github.com/danielmarbach/PerformanceTricksAzureSDK</a>
							</p>
							<p>Happy coding!</p>
							<p style="font-size: medium">
								<i class="fa fa-twitter" aria-hidden="true"><a href="https://twitter.com/danielmarbach"> danielmarbach</a></i>
								<i class="fa fa-envelope" aria-hidden="true"> <a										
										href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#100;&#97;&#110;&#105;&#101;&#108;&#46;&#109;&#97;&#114;&#98;&#97;&#99;&#104;&#64;&#111;&#112;&#101;&#110;&#112;&#108;&#97;&#99;&#101;&#46;&#110;&#101;&#116;">&#100;&#97;&#110;&#105;&#101;&#108;&#46;&#109;&#97;&#114;&#98;&#97;&#99;&#104;&#64;&#111;&#112;&#101;&#110;&#112;&#108;&#97;&#99;&#101;&#46;&#110;&#101;&#116;</a></i>
							</p>
						</div>
					</div>
					<aside class="notes">
					</aside>
				</section>
			</section>

		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/search/search.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			controls: true,
			progress: true,
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
		});
	</script>
</body>

</html>