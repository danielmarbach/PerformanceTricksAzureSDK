<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Performance tricks I learned from contributing to the Azure .NET SDK</title>

	<meta name="description"
		content="As a practical learner, I've found that performance optimizations have been my biggest challenge and the place I've learned the tricks that are the most helpful. These lessons have come by trial and error. As it turns out, the Azure .NET SDK was a perfect “playground” for learning new tricks because it's maintained by people who care and give feedback. Over the past few years, I've contributed over fifty pull requests to the Azure .NET SDK and some of them got accepted. In this session, I'll walk you through the performance improvements I learned from my experiments. Some “superpowers” you will learn are spotting closure allocations and opportunities for memory pooling and, best of all, how to improve them.">
	<meta name="author" content="Daniel Marbach">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="dist/custom.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-background="img/juggler-trick-magician-juggle-1216853.jpg">
				<div style="left: 10; width: 52%; padding: 25px; font-size: 30px; text-align: left;">
					<h3 style="text-transform: none;color: rgba(31, 129, 74, 0.9);">Performance tricks I learned from
						contributing to the Azure .NET SDK</h3>
					<p>
						<a style="text-transform: none;color: rgba(31, 129, 74, 0.6);"
							href="https://twitter.com/danielmarbach">Daniel Marbach</a>
					</p>
				</div>
			</section>
			<section>
				<section data-background="img/architecture-g104d6d62d_1280.jpg">
					<div class="image-slide-box">
						<h2>Introduction</h2>
						<p>Focus on performance optimization in .NET Code and not architecture.</p>
					</div>
					<aside class="notes">
						<ul>
							<li>Not about horizontal and vertical scaling</li>
							<li>C/C++ is less and less needed</li>
						</ul>
					</aside>
				</section>
				<section data-background="img/tarot-g4ac5fb817_1280.jpg">
					<div class="image-slide-box">
						<h2>Esoteric</h2>
						<p>Being called out for premature optimizations.</p>
					</div>
					<aside class="notes">
						<ul>
							<li>Don't jump to conclusions and apply them blindly.</li>
							<li>Code executed under scale it matters: More efficient in resource usage, execution time,
								throughput and memory usage</li>
							<li>But what does at scale even mean? How can I find out whether the optimizations I'm
								trying to make have value, and I'm not getting called out by my colleagues for premature
								optimizations?</li>
						</ul>
					</aside>
				</section>
			</section>
			<section data-background="img/animal-3346192_1280.jpg">
				<div
					style="left: 10; width: 35%; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: left;">
					<h5>At Scale implementation details matter</h5>
					<div style="font-style: italic;">
						<p>&ldquo;Scale for an application can mean the number of users that will concurrently connect
							to the application at any given time, the amount of input to process or the number of times
							data needs to be processed.</p>
						<p>For us, as engineers, it means we have to know <b>what to ignore</b> and knowing <b>what to
								pay close attention to</b>.&rdquo; <a
								href="https://speakerdeck.com/davidfowl/implementation-details-matter">David Fowler</a>
						</p>
					</div>
				</div>
				<aside class="notes">
					<ul>
						<li>Discover the assumptions that have accumulated over time</li>
						<li>Pay close attention to what is instantiated, parsed, processed etc. per request</li>
						<li>How those assumptions in the code base affect the performance characteristics (memory,
							throughput...) at scale</li>
					</ul>
				</aside>
			</section>
			<section>
				<section data-background-video="vids/Give-me-the-code-natalia.mp4">
				</section>
				<section data-auto-animate>
					<ul>
						<li data-id="allocations">Avoid excessive allocations to reduce the GC overhead</li>
						<li data-id="copying">Avoid unnecessary copying of memory</li>
					</ul>
					<h2 class="r-fit-text" data-id="thumb">Rules of thumb</h2>
				</section>
				<section data-auto-animate>
					<ul>
						<li data-id="allocations">Avoid excessive allocations to reduce the GC overhead</li>
						<ul>
							<li class="fragment fade-in">Be aware of closure allocations</li>
							<li class="fragment fade-in">Be aware of parameter overloads</li>
							<li class="fragment fade-in">Where possible and feasible use value types <br />but pay
								attention to unnecessary boxing</li>
							<li class="fragment fade-in">Think at least twice before using LINQ <br /> or
								unnecessary enumeration on the hot path</li>
							<li class="fragment fade-in">Pool and re-use buffers</li>
							<li class="fragment fade-in">For smaller local buffers, consider using the stack</li>
						</ul>
						<li data-id="copying">Avoid unnecessary copying of memory</li>
					</ul>
				</section>
			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Think at least twice before using LINQ or unnecessary enumeration on the hot path</p>
					</div>
					<aside class="notes">
						LINQ is great, and I wouldn't want to miss it at all. Yet, on the hot path it is far too easy to
						get into troubles with LINQ because it can cause hidden allocations and is difficult for the JIT
						to optimize. Let's look at a piece of code from the AmqpReceiver
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|8|10|11" data-trim data-noescape><script type="text/template">
							public class AmqpReceiver {
								
								ConcurrentBag<Guid> _lockedMessages = new ();
								
								public Task CompleteAsync(IEnumerable<string> lockTokens) 
									=> CompleteInternalAsync(lockTokens);
								
								Task CompleteInternalAsync(IEnumerable<string> lockTokens) 
								{
									Guid[] lockTokenGuids = lockTokens.Select(token => new Guid(token)).ToArray();
									if (lockTokenGuids.Any(lockToken => _lockedMessages.Contains(lockToken))) 
									{
									  // do special path accessing lockTokenGuids
									  return Task.CompletedTask;
									}
									// do normal path accessing lockTokenGuids
									return Task.CompletedTask;
								}
							}
						</script></code></pre>
					<aside class="notes">
						<ul>
							<li>Explain AmqpReceiver</li>
							<li>Enumerable, string to guid, Any with contains</li>
							<li>Decompile</li>
						</ul>
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|8-9|10" data-trim data-noescape><script type="text/template">
							public class AmqpReceiver {
	
								// ...
								// Compiler generated chunk we are not really interested in right now
	
								private Task CompleteInternalAsync(IEnumerable<string> lockTokens)
								{
									Enumerable.Any(Enumerable.ToArray(Enumerable.Select(lockTokens, <>c.<>9__2_0 ?? 
										(<>c.<>9__2_0 = new Func<string, Guid>(<>c.<>9.<CompleteInternalAsync>b__2_0)))), 
											new Func<Guid, bool>(<CompleteInternalAsync>b__2_1));
									return Task.CompletedTask;
								}
							
								[CompilerGenerated]
								private bool <CompleteInternalAsync>b__2_1(Guid lockToken)
								{
									return Enumerable.Contains(_requestResponseLockedMessages, lockToken);
								}
							}
						</script></code></pre>
					<aside class="notes">
						For every call of CompleteInternalAsync a new instance of Func&lt;Guid, bool&gt; is allocated
						that points to &lt;CompleteInternalAsync&gtb__2_1. A closure captures the _lockedMessages and
						the lockToken as state.
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens) 
							=> CompleteInternalAsync(lockTokens);

						Task CompleteInternalAsync(IEnumerable<string> lockTokens) 
						{
							Guid[] lockTokenGuids = lockTokens.Select(token => new Guid(token)).ToArray();
							foreach (var tokenGuid in lockTokenGuids) 
							{
								if (_requestResponseLockedMessages.Contains(tokenGuid))
								{
									return Task.CompletedTask;
								}
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|6-8" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens) 
							=> CompleteInternalAsync(lockTokens);

						Task CompleteInternalAsync(IEnumerable<string> lockTokens) 
						{
							Guid[] array = Enumerable.ToArray(Enumerable.Select(lockTokens, 
								<>c.<>9__2_0 ?? 
								(<>c.<>9__2_0 = new Func<string, Guid>(<>c.<>9.<CompleteInternalAsync>b__2_0))));

							int num = 0;
							while (num < array.Length)
							{
								Guid item = array[num];
								if (_requestResponseLockedMessages.Contains(item))
								{
									return Task.CompletedTask;
								}
								num++;
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section>
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:35%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~20-40%<br />
								<i class="fa fa-trash-o"></i> ~20-40%</p>
						</div>
						<img src="benchmarks/LinqBeforeAfterComparisonCropped.png" />
					</div>
					<aside class="notes">
						By getting rid of the Any we were able to squeeze out some good performance improvements.
						Sometimes, though, we can do even more. For example, there are a few general rules we can follow
						when we refactor a code path using LINQ to collection-based operations.
					</aside>
				</section>
				<section>
					<h2 class="r-fit-text" data-id="thumb">LINQ to collection-based operations</h2>
					<ul>
						<li class="fragment fade-in">Use <code>Array.Empty&lt;T&gt;</code> to represent empty arrays
						</li>
						<li class="fragment fade-in">Use <code>Enumerable.Empty&lt;T&gt;</code> to represent empty
							enumerables</li>
						<li class="fragment fade-in">Prevent collections from growing</li>
						<li class="fragment fade-in">Use concrete collection types</li>
						<li class="fragment fade-in">Leverage pattern matching or
							<code>Enumerable.TryGetNonEnumeratedCount</code>
						</li>
					</ul>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|6" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens) 
							=> CompleteInternalAsync(lockTokens);

						Task CompleteInternalAsync(IEnumerable<string> lockTokens) 
						{
							Guid[] lockTokenGuids = lockTokens.Select(token => new Guid(token)).ToArray();
							foreach (var tokenGuid in lockTokenGuids) 
							{
								if (_requestResponseLockedMessages.Contains(tokenGuid))
								{
									return Task.CompletedTask;
								}
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.4em"><code class="language-csharp" data-line-numbers="|2-6|10|12-13|17-18" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens) {
							IReadOnlyCollection<string> readOnlyCollection = lockTokens switch
							{
								IReadOnlyCollection<string> asReadOnlyCollection => asReadOnlyCollection,
								_ => lockTokens.ToArray(),
							};
							return CompleteInternalAsync(readOnlyCollection);
						}
						
						Task CompleteInternalAsync(IReadOnlyCollection<string> lockTokens)
						{
							int count = lockTokens.Count;
							Guid[] lockTokenGuids = count == 0 ? Array.Empty<Guid>() : new Guid[count];
							int index = 0;
							foreach (var token in lockTokens)
							{
								var tokenGuid = new Guid(token);
								lockTokenGuids[index++] = tokenGuid;
								if (_requestResponseLockedMessages.Contains(tokenGuid))
								{
									return Task.CompletedTask;
								}
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
					<aside class="notes">
						TBD
					</aside>
				</section>

			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Be aware of closure allocations</p>
					</div>
					<aside class="notes">
						We have already touched a bit on closure allocations during our LINQ performance investigations.
						But closures can occur anywhere where we have lambdas (Action or Func delegates) being invoked
						that access state from the outside of the lambda.
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						async Task RunOperation(
							Func<TimeSpan, Task> operation, 
							TransportConnectionScope scope, CancellationToken cancellationToken) 
						{
							TimeSpan tryTimeout = CalculateTryTimeout(0);
							// omitted
							while (!cancellationToken.IsCancellationRequested) {
								if (IsServerBusy) {
									await Task.Delay(ServerBusyBaseSleepTime, cancellationToken);
								}
						
								try	{
									await operation(tryTimeout);
									return;
								}
								catch {
									// omitted
								}
							}
						}
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="|1,4" data-trim data-noescape><script type="text/template">
						TransportMessageBatch messageBatch = null;
						Task createBatchTask = _retryPolicy.RunOperation(async (timeout) =>
						{
							messageBatch = await CreateMessageBatchInternalAsync(options, timeout);
						},
						_connectionScope,
						cancellationToken);
						await createBatchTask;
						return messageBatch;
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.45em"><code class="language-csharp" data-line-numbers="|2,8" data-trim data-noescape><script type="text/template">
						if (num1 != 0)	{
							this.\u003C\u003E8__1 = new AmqpSender.\u003C\u003Ec__DisplayClass16_0();
							this.\u003C\u003E8__1.\u003C\u003E4__this = this.\u003C\u003E4__this;
							this.\u003C\u003E8__1.options = this.options;
							this.\u003C\u003E8__1.messageBatch = (TransportMessageBatch) null;

							configuredTaskAwaiter = amqpSender._retryPolicy.RunOperation(
								new Func<TimeSpan, Task>((object) this.\u003C\u003E8__1,
									 __methodptr(\u003CCreateMessageBatchAsync\u003Eb__0)), 
									 (TransportConnectionScope) amqpSender._connectionScope, 
									 this.cancellationToken).ConfigureAwait(false).GetAwaiter();

							// rest omitted
						}
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.45em"><code class="language-csharp" data-line-numbers="|1|2,3|14" data-trim data-noescape><script type="text/template">
						internal async ValueTask<TResult> RunOperation<T1, TResult>(
							Func<T1, TimeSpan, CancellationToken, ValueTask<TResult>> operation,
							T1 t1,
							TransportConnectionScope scope,
							CancellationToken cancellationToken) {
							TimeSpan tryTimeout = CalculateTryTimeout(0);
							// omitted
							while (!cancellationToken.IsCancellationRequested) {
								if (IsServerBusy) {
									await Task.Delay(ServerBusyBaseSleepTime, cancellationToken);
								}
						
								try	{
									return await operation(t1, tryTimeout, cancellationToken);
								}
								catch {
									// omitted
								}
							}
						}
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="|1|2,3|6,8,9,12" data-trim data-noescape><script type="text/template">
						internal async ValueTask RunOperation<T1>(
							Func<T1, TimeSpan, CancellationToken, ValueTask> operation,
							T1 t1,
							TransportConnectionScope scope,
							CancellationToken cancellationToken) =>
								await RunOperation(static async (value, timeout, token) =>
								{
									var (t1, operation) = value;
									await operation(t1, timeout, token);
									return default(object);
								}, 
							(t1, operation),
							scope, cancellationToken);
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.3em"><code class="language-csharp" data-line-numbers="|4,9" data-trim data-noescape><script type="text/template">
						if (num1 != 0) {
							configuredTaskAwaiter = t1._retryPolicy
								.RunOperation<AmqpSender, CreateMessageBatchOptions, TransportMessageBatch>(
								AmqpSender.\u003C\u003Ec.\u003C\u003E9__16_0 ?? (AmqpSender.\u003C\u003Ec.\u003C\u003E9__16_0 = 
									new Func<AmqpSender, CreateMessageBatchOptions, TimeSpan, CancellationToken, Task<TransportMessageBatch>>(
										(object) AmqpSender.\u003C\u003Ec.\u003C\u003E9, 
										__methodptr(\u003CCreateMessageBatchAsync\u003Eb__16_0))), 
										t1, 
										this.options, 
										(TransportConnectionScope) t1._connectionScope, 
										this.cancellationToken).ConfigureAwait(false).GetAwaiter();
							// rest omitted
						}
						</script></code></pre>
					<aside class="notes">
						With that small change, we save the display class and the function delegate allocations and can
						properly usage methods that support value tasks without having to allocate a task instance when
						not necessary.
						To demonstrate how these can add up in real-world scenarios, let me show you a before and after
						comparison when I removed the closure allocations for NServiceBus pipeline execution
					</aside>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section>
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:20%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~500%<br />
								<i class="fa fa-trash-o"></i> ~Gone!</p>
						</div>
						<img src="benchmarks/NServiceBusPipelineExecutionCropped.png" />
					</div>
				</section>
				<section>
					<h2 class="r-fit-text" data-id="thumb">How to detect those allocations?</h2>
					<ul>
						<li class="fragment fade-in">Use memory profilers and watch out for excessive allocations of
							<code>*__DisplayClass*</code> or various variants of <code>Action*</code> and
							<code>Func*</code>
						</li>
						<li class="fragment fade-in">Use tools like <a
								href="https://plugins.jetbrains.com/plugin/9223-heap-allocations-viewer">Heap Allocation
								Viewer (Rider)</a> or <a
								href="https://marketplace.visualstudio.com/items?itemName=MukulSabharwal.ClrHeapAllocationAnalyzer">Heap
								Allocation Analyzer (Visual Studio)</a></li>
						<li class="fragment fade-in">Many built-in .NET types that use delegates have nowadays generic
							overloads that allow to pass state into the delegate.</li>
					</ul>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						var someState1 = new object();
						var someOtherState = 42;
						
						var dictionary = new ConcurrentDictionary<string, string>();
						
						dictionary.GetOrAdd("SomeKey", static (key, state) => {
							var (someState, someOtherState) = state;
						
							return $"{someState}_{someOtherState}";
						}, (someState1, someOtherState));
						</script></code></pre>
				</section>
			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div
						style="margin-left: auto; margin-right: auto; width: 60%; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 25px; font-size: 25px; text-align: left;">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Pool and re-use buffers (and larger objects)</p>
					</div>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="|4" data-trim data-noescape><script type="text/template">
						// somewhere from the network we get a guid as a byte array
						var data = new ArraySegment<byte>(Guid.NewGuid().ToByteArray());

						var guidBuffer = new byte[16];
						Buffer.BlockCopy(data.Array, data.Offset, guidBuffer, 0, 16);
						var lockTokenGuid = new Guid(guidBuffer);
						</script></code></pre>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="|1|4" data-trim data-noescape><script type="text/template">
						byte[] guidBuffer =  ArrayPool<byte>.Shared.Rent(16);
						Buffer.BlockCopy(data.Array, data.Offset, guidBuffer, 0, 16);
						var lockTokenGuid = new Guid(guidBuffer);
						ArrayPool<byte>.Shared.Return(guidBuffer);
						</script></code></pre>
				</section>
				<section>
					<img src="benchmarks/BufferAndBlockCopyPooling.png" />
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="|1|2" data-trim data-noescape><script type="text/template">
						Span<byte> guidBytes = stackalloc byte[16];
						data.AsSpan().CopyTo(guidBytes);
						var lockTokenGuid = new Guid(guidBytes);
						</script></code></pre>
				</section>
				<section>
					<img src="benchmarks/StackallocWithGuid.png" />
				</section>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/search/search.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			controls: true,
			progress: true,
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
		});
	</script>
</body>

</html>