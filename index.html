<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport"
		content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Performance tricks I learned from contributing open source .NET packages</title>
	<meta name="author" content="Daniel Marbach">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">
	<link rel="stylesheet" href="css/font-awesome.min.css">
	<link rel="stylesheet" href="dist/custom.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-background="img/juggler-trick-magician-juggle-1216853.jpg">
				<div style="left: 10; width: 52%; padding: 25px; font-size: 50px; text-align: left;">
					<h3 style="text-transform: none;color: rgba(31, 129, 74, 0.9);">Performance tricks I learned from
						contributing to open source .NET packages</h3>
					<p style="text-transform: none;color: rgba(31, 129, 74, 0.6); font-size: 30px;">
						<i class="fa fa-twitter" aria-hidden="true"><a
								style="text-transform: none;color: rgba(31, 129, 74, 0.6)"
								href="https://twitter.com/danielmarbach"> danielmarbach</a> |</i>
						<i class="fa fa-envelope" aria-hidden="true"> <a
								style="text-transform: none;color: rgba(31, 129, 74, 0.6)"
								href="mailto:&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#100;&#97;&#110;&#105;&#101;&#108;&#46;&#109;&#97;&#114;&#98;&#97;&#99;&#104;&#64;&#112;&#97;&#114;&#116;&#105;&#99;&#117;&#108;&#97;&#114;&#46;&#110;&#101;&#116;">&#100;&#97;&#110;&#105;&#101;&#108;&#46;&#109;&#97;&#114;&#98;&#97;&#99;&#104;&#64;&#112;&#97;&#114;&#116;&#105;&#99;&#117;&#108;&#97;&#114;&#46;&#110;&#101;&#116;</a></i>
					</p>
				</div>
				<!-- Short Version -->
				<aside class="notes">
					<ul>
						<li>As a practical learner I found the Azure SDK repository the perfect spot to learn and apply
							interesting performance optimization techniques</li>
						<li>Over 70 contributions over the years</li>
						<li>In this talk I have summarized some of the key learnings of my adventures in the Azure SDK
							repository so that you can have a headstart should you wish to start applying performance
							optimization techniques in your code bases.</li>
					</ul>
				</aside>
			</section>
			<section>
				<section data-background="img/architecture-g104d6d62d_1280.jpg">
					<div class="image-slide-box">
						<h2>Introduction</h2>
						<p>Focus on performance optimization in .NET Code and not architecture.</p>
					</div>
					<aside class="notes">
						<ul>
							<li>Not about horizontal and vertical scaling</li>
							<li>Not about tools like Benchmark.NET or memory and tracing profilers.</li>
							<li>Performance optimizations that can be done in code</li>
							<li>.NET has been evolving over the years into a modern and high-performance platform.</li>
							<li>C/C++ is less and less needed to achieve code that performs well at scale</li>
						</ul>
					</aside>
				</section>
				<section data-background="img/tarot-g4ac5fb817_1280.jpg">
					<div class="image-slide-box">
						<h2>Esoteric</h2>
						<p>Being called out for premature optimizations.</p>
					</div>
					<aside class="notes">
						<ul>
							<li>"Wow, that's crazy, is the complexity of this change really worth it? Isn't that
								premature optimization?" </li>
							<li>Some optimizations shown here are sometimes called out as esoteric.
							</li>
							<li>Don't jump to conclusions and apply them blindly.</li>
							<li>Performance improvements can be addictive, nobody likes to optimize code that is fast
								enough or only executed once a day.</li>
							<li>Code executed under scale it matters: More efficient in resource usage, execution time,
								throughput and memory usage</li>
						</ul>
					</aside>
				</section>
			</section>
			<section data-background="img/owl-1576572_1280.jpg">
				<div
					style="margin-left: auto; margin-right: 10; width: 35%; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 25px; font-size: 50px; text-align: left;">
					<h5>At Scale implementation details matter</h5>
					<div style="font-style: italic;">
						<p>&ldquo;Scale for an application can mean the number of users that will concurrently connect
							to the application at any given time, the amount of input to process or the number of times
							data needs to be processed.</p>
						<p>For us, as engineers, it means we have to know <b>what to ignore</b> and knowing <b>what to
								pay close attention to</b>.&rdquo; <a
								href="https://speakerdeck.com/davidfowl/implementation-details-matter">David Fowler</a>
						</p>
					</div>
				</div>
				<aside class="notes">
					<ul>
						<li>Discover the assumptions that have accumulated over time</li>
						<li>Pay close attention to what is instantiated, parsed, processed etc. per request</li>
						<li>How those assumptions in the code base affect the performance characteristics (memory,
							throughput...) at scale</li>
						<li>As developers and engineers we want rules that we can apply. Relying on rules for the
							majority of cases helps us to know when and what to apply..</li>
					</ul>
				</aside>
			</section>
			<section>
				<section data-background="img/office-4249395_1280.jpg">
					<aside class="notes">
						As developers and engineers we want rules that we can apply. I have compiled them based on my
						experience.
					</aside>
				</section>
				<section>
					<ul class="r-fit-text">
						<li>Avoid excessive allocations to reduce the GC overhead</li>
						<li>Avoid unnecessary copying of memory</li>
					</ul>
					<aside class="notes">
						These are the two high level categories we are going to focus on. For each section I will
						introduce a few handy rules that should help you make the right tradeoffs.
					</aside>
				</section>
			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Think at least twice before using LINQ or unnecessary enumeration on the hot path</p>
					</div>
					<aside class="notes">
						LINQ is great, and I wouldn't want to miss it at all. Yet, on the hot path it is far too easy to
						get into troubles with LINQ because it can cause hidden allocations and is difficult for the JIT
						to optimize. Let's look at a piece of code from the AmqpReceiver (The "driver" behind Service
						Bus and Event Hub Message/Event receival)
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.8em"><code class="language-csharp" data-line-numbers="|8|10|11" data-trim data-noescape><script type="text/template">
							public class AmqpReceiver {

								ConcurrentBag<Guid> _lockedMessages = new ();

								public Task CompleteAsync(IEnumerable<string> lockTokens)
									=> CompleteInternalAsync(lockTokens);

								Task CompleteInternalAsync(IEnumerable<string> lockTokens)
								{
									Guid[] lockTokenGuids = lockTokens.Select(token => new Guid(token)).ToArray();
									if (lockTokenGuids.Any(lockToken => _lockedMessages.Contains(lockToken)))
									{
									  // do special path accessing lockTokenGuids
									  return Task.CompletedTask;
									}
									// do normal path accessing lockTokenGuids
									return Task.CompletedTask;
								}
							}
						</script></code></pre>
					<medium class="code-header">Avoid LINQ on the hot path.</medium>
					<aside class="notes">
						<ul>
							<li>Enumerable (broadest type according to SDK guidelines), string to guid, Any with
								contains</li>
							<li>Decompile</li>
						</ul>
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.8em"><code class="language-csharp" data-line-numbers="|8-9|10,17" data-trim data-noescape><script type="text/template">
							public class AmqpReceiver {

								// ...
								// Compiler generated chunk we are not really interested in right now

								private Task CompleteInternalAsync(IEnumerable<string> lockTokens)
								{
									Enumerable.Any(Enumerable.ToArray(Enumerable.Select(lockTokens, <>c.<>9__2_0 ??
										(<>c.<>9__2_0 = new Func<string, Guid>(<>c.<>9.<CompleteInternalAsync>b__2_0)))),
											new Func<Guid, bool>(<CompleteInternalAsync>b__2_1));
									return Task.CompletedTask;
								}

								[CompilerGenerated]
								private bool <CompleteInternalAsync>b__2_1(Guid lockToken)
								{
									return Enumerable.Contains(_lockedMessages, lockToken);
								}
							}
						</script></code></pre>
					<medium class="code-header">Avoid LINQ on the hot path.</medium>
					<aside class="notes">
						For every call of CompleteInternalAsync a new instance of Func&lt;Guid, bool&gt; is allocated
						that points to &lt;CompleteInternalAsync&gtb__2_1. A closure captures the _lockedMessages and
						the lockToken as state. This allocation is unnecessary.<br />
						It is possible to simply turn the Any into a loop.
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.8em"><code class="language-csharp" data-line-numbers="|7-13" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens)
							=> CompleteInternalAsync(lockTokens);

						Task CompleteInternalAsync(IEnumerable<string> lockTokens)
						{
							Guid[] lockTokenGuids = lockTokens.Select(token => new Guid(token)).ToArray();
							foreach (var tokenGuid in lockTokenGuids)
							{
								if (_requestResponseLockedMessages.Contains(tokenGuid))
								{
									return Task.CompletedTask;
								}
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
					<medium class="code-header">Avoid LINQ on the hot path.</medium>
					<aside class="notes">
						This gets then compiled down to.
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.8em"><code class="language-csharp" data-line-numbers="|6-8" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens)
							=> CompleteInternalAsync(lockTokens);

						Task CompleteInternalAsync(IEnumerable<string> lockTokens)
						{
							Guid[] array = Enumerable.ToArray(Enumerable.Select(lockTokens,
								<>c.<>9__2_0 ??
								(<>c.<>9__2_0 = new Func<string, Guid>(<>c.<>9.<CompleteInternalAsync>b__2_0))));

							int num = 0;
							while (num < array.Length)
							{
								Guid item = array[num];
								if (_requestResponseLockedMessages.Contains(item))
								{
									return Task.CompletedTask;
								}
								num++;
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
					<medium class="code-header">Avoid LINQ on the hot path.</medium>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section data-background="benchmarks/LinqBeforeAfterComparisonCropped.png" data-background-size="75%">
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:35%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 50px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~20-40%<br />
								<i class="fa fa-trash-o"></i> ~20-40%
							</p>
						</div>
					</div>
					<aside class="notes">
						By getting rid of the Any we were able to squeeze out some good performance improvements.
						Sometimes, though, we can do even more. For example, there are a few general rules we can follow
						when we refactor a code path using LINQ to collection-based operations.
					</aside>
				</section>
				<section data-background="img/office-4249395_1280.jpg">
					<aside class="notes">
						As developers and engineers we want rules that we can apply. I have compiled them based on my
						experience.
					</aside>
				</section>
				<section data-auto-animate>
					<h2 class="r-fit-text">LINQ to collection-based operations</h2>
					<ul class="r-fit-text">
						<li class="fragment fade-in">Use <code>Array.Empty&lt;T&gt;</code> to represent empty arrays
						</li>
						<li class="fragment fade-in">Use <code>Enumerable.Empty&lt;T&gt;</code> to represent empty
							enumerables</li>
						<li class="fragment fade-in">Prevent collections from growing</li>
						<li class="fragment fade-in">Use concrete collection types</li>
						<li class="fragment fade-in">Leverage pattern matching or
							<code>Enumerable.TryGetNonEnumeratedCount</code>
						</li>
						<li class="fragment fade-in">Wait with instantiating collections until really needed</li>
						<li class="fragment fade-in">There be dragons
							<ul>
								<li>Align access or use unsafe to avoid bound checks</li>
								<li>Use <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.collectionsmarshal">CollectionMarshal</a>/<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal">MemoryMarshal</a>/<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafe">Unsafe</a> to access the underlying data directly</li>
							</ul>
						</li>
						<li class="fragment fade-in">Keep yourself up to date with latest .NET performance improvements</li>
					</ul>
					<!-- For the short 45 min version -->
					<aside class="notes">
						I'm not going to cover the details of these rules. I'm leaving them here for you as a reference.
						Should you wish to dig deeper I will be handing out a link to a recording of a longer version of
						this talk that goes into more details and shows a before and after of the code we already
						optimized. Just to show you what gains we can achieve in the best case here is the improvements
						we can by applying all those rules to the previous code in the best/optimal case.
					</aside>
				</section>
				<section data-background="benchmarks/PerformanceNet8.png" data-background-size="100%">
					<aside class="notes">
						As developers and engineers we want rules that we can apply. I have compiled them based on my
						experience.
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.8em"><code class="language-csharp" data-line-numbers="|6" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens)
							=> CompleteInternalAsync(lockTokens);

						Task CompleteInternalAsync(IEnumerable<string> lockTokens)
						{
							Guid[] lockTokenGuids = lockTokens.Select(token => new Guid(token)).ToArray();
							foreach (var tokenGuid in lockTokenGuids)
							{
								if (_requestResponseLockedMessages.Contains(tokenGuid))
								{
									return Task.CompletedTask;
								}
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
					<medium class="code-header">Avoid LINQ on the hot path.</medium>
					<aside class="notes">
						In order to know which of these principles we can apply we have to be aware of what collection
						types are usually passed as parameters to the CompleteAsync method. In the .NET Azure SDK the
						lockTokens enumerable is almost always an already materialized collection type that implements
						IReadOnlyCollection (context)
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.7em"><code class="language-csharp" data-line-numbers="|2-6|10|12-13|17-18" data-trim data-noescape><script type="text/template">
						public Task CompleteAsync(IEnumerable<string> lockTokens) {
							IReadOnlyCollection<string> readOnlyCollection = lockTokens switch
							{
								IReadOnlyCollection<string> asReadOnlyCollection => asReadOnlyCollection,
								_ => lockTokens.ToArray(),
							};
							return CompleteInternalAsync(readOnlyCollection);
						}

						Task CompleteInternalAsync(IReadOnlyCollection<string> lockTokens)
						{
							int count = lockTokens.Count;
							Guid[] lockTokenGuids = count == 0 ? Array.Empty<Guid>() : new Guid[count];
							int index = 0;
							foreach (var token in lockTokens)
							{
								var tokenGuid = new Guid(token);
								lockTokenGuids[index++] = tokenGuid;
								if (_requestResponseLockedMessages.Contains(tokenGuid))
								{
									return Task.CompletedTask;
								}
							}
							return Task.CompletedTask;
						}
						</script></code></pre>
					<medium class="code-header">Avoid LINQ on the hot path.</medium>
					<aside class="notes">
						The internal method signature has to be changed to accept a parameter of type
						IReadOnlyCollection. For the empty case we can directly use the empty array and in the other
						cases we use an array. Because we have the count available, the array can be properly
						initialized with the desired count (if we'd be using lists this would be even more important
						because lists can automatically grow which can allocate a lot and takes time).
					</aside>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section data-background="benchmarks/LinqAfterComparisonCropped.png" data-background-size="75%">
					<div style="position:relative;">
						<div class="fragment fade-in-then-out"
							style="position: absolute; left:20%; top:35%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 50px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~5-64%<br />
								<i class="fa fa-trash-o"></i> ~23-61%
							</p>
						</div>
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:35%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(168, 114, 33, 0.9); color: #fff; padding: 25px; font-size: 50px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> +56%<br />
								<i class="fa fa-trash-o"></i> ~23-61%
							</p>
						</div>
					</div>
					<aside class="notes">
						<ul>
							<li>Lazy enumeration is much worse.</li>
							<li>Is that an indication we shouldn't be doing such a refactoring?</li>
							<li>Well it depends</li>
							<li>If you know what is passed into it it might be a good optimization.</li>
							<li>Otherwise readability should be the key driver instead of trying to gold plate every
								part of the code base</li>
							<li>There are likely other areas that are slowing things down more. </li>
							<li>Fire up your favorite memory and performance profiler and get a better understanding
							</li>
							<li>Like with all things, it is crucial to know when to stop on a given code path and find
								other areas that are more impactful to optimize. The context of the piece of code that
								you are trying to optimize is key.</li>
						</ul>
					</aside>
				</section>
			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Be aware of closure allocations</p>
					</div>
					<aside class="notes">
						We have already touched a bit on closure allocations during our LINQ performance investigations.
						But closures can occur anywhere where we have lambdas (Action or Func delegates) being invoked
						that access state from the outside of the lambda.
					</aside>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.9em"><code class="language-csharp" data-line-numbers="|1|2|13" data-trim data-noescape><script type="text/template">
						async Task RunOperation(
							Func<TimeSpan, Task> operation,
							TransportConnectionScope scope, CancellationToken cancellationToken)
						{
							TimeSpan tryTimeout = CalculateTryTimeout(0);
							// omitted
							while (!cancellationToken.IsCancellationRequested) {
								if (IsServerBusy) {
									await Task.Delay(ServerBusyBaseSleepTime, cancellationToken);
								}

								try	{
									await operation(tryTimeout);
									return;
								}
								catch {
									// omitted
								}
							}
						}
						</script></code></pre>
					<medium class="code-header">Remove closure allocations.</medium>
					<aside class="notes">
						Retry method from the ServiceBus SDK that retries operations on certain server failure scenarios
						(like RetryAfter when busy).
					</aside>
				</section>
				<section>
					<pre class="" style="font-size: 0.7em"><code class="language-csharp" data-line-numbers="|1,4-5" data-trim data-noescape><script type="text/template">
						TransportMessageBatch messageBatch = null;
						Task createBatchTask = _retryPolicy.RunOperation(async (timeout) =>
						{
							messageBatch =
								await CreateMessageBatchInternalAsync(options, timeout);
						},
						_connectionScope,
						cancellationToken);
						await createBatchTask;
						return messageBatch;
						</script></code></pre>
					<medium class="code-header">Remove closure allocations.</medium>
					<aside class="notes">
						Notice the message batch local is captured as well as the options instance.
						Decompile the code.
					</aside>
				</section>
				<section>
					<pre class="" style="font-size: 0.7em"><code class="language-csharp" data-line-numbers="|2,8" data-trim data-noescape><script type="text/template">
						if (num1 != 0)	{
							this.\u003C\u003E8__1 = new AmqpSender.\u003C\u003Ec__DisplayClass16_0();
							this.\u003C\u003E8__1.\u003C\u003E4__this = this.\u003C\u003E4__this;
							this.\u003C\u003E8__1.options = this.options;
							this.\u003C\u003E8__1.messageBatch = (TransportMessageBatch) null;

							configuredTaskAwaiter = amqpSender._retryPolicy.RunOperation(
								new Func<TimeSpan, Task>((object) this.\u003C\u003E8__1,
									 __methodptr(\u003CCreateMessageBatchAsync\u003Eb__0)),
									 (TransportConnectionScope) amqpSender._connectionScope,
									 this.cancellationToken).ConfigureAwait(false).GetAwaiter();

							// rest omitted
						}
						</script></code></pre>
					<medium class="code-header">Remove closure allocations.</medium>
				</section>
				<section>
					<pre class="stretch" style="font-size: 0.9em"><code class="language-csharp" data-line-numbers="|1|2,3|14" data-trim data-noescape><script type="text/template">
						internal async ValueTask<TResult> RunOperation<T1, TResult>(
							Func<T1, TimeSpan, CancellationToken, ValueTask<TResult>> operation,
							T1 t1,
							TransportConnectionScope scope,
							CancellationToken cancellationToken) {
							TimeSpan tryTimeout = CalculateTryTimeout(0);
							// omitted
							while (!cancellationToken.IsCancellationRequested) {
								if (IsServerBusy) {
									await Task.Delay(ServerBusyBaseSleepTime, cancellationToken);
								}

								try	{
									return await operation(t1, tryTimeout, cancellationToken);
								}
								catch {
									// omitted
								}
							}
						}
						</script></code></pre>
					<medium class="code-header">Remove closure allocations.</medium>
					<aside class="notes">
						We can augment this code to accept an input T1 and return an output. The input argument or state
						is then passed into the operation method.
						With that trick we can build a library tool that allows to deal with functions that return state
						as well as actions that return nothing. Essentially properly modelling void to make functional
						programmers happy.
					</aside>
				</section>
				<section>
					<pre class="" style="font-size: 0.60em"><code class="language-csharp" data-line-numbers="|1|2,3|6,8,9,12|8,12|6,8,9,12" data-trim data-noescape><script type="text/template">
						internal async ValueTask RunOperation<T1>(
							Func<T1, TimeSpan, CancellationToken, ValueTask> operation,
							T1 t1,
							TransportConnectionScope scope,
							CancellationToken cancellationToken) =>
								await RunOperation(static async (value, timeout, token) =>
								{
									var (t1, operation) = value;
									await operation(t1, timeout, token);
									return default(object);
								},
							(t1, operation),
							scope, cancellationToken);
						</script></code></pre>
					<medium class="code-header">Remove closure allocations.</medium>
					<aside class="notes">
						<ul>
							<li>Switch to ValueTask because some operations returned value tasks</li>
							<li>Use CSharp 9 static lambda features to make it impossible to access state within the
								delegate that is outside</li>
							<li>Use the state argument to pass in the state from the method including the operation as a
								value tuple into the function</li>
							<li>Deconstruct the value tuple and execute the operation passing all necessary state to it.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<pre class="" style="font-size: 0.6em"><code class="language-csharp" data-line-numbers="|4,9" data-trim data-noescape><script type="text/template">
						if (num1 != 0) {
							configuredTaskAwaiter = t1._retryPolicy
								.RunOperation<AmqpSender, CreateMessageBatchOptions, TransportMessageBatch>(
								AmqpSender.\u003C\u003Ec.\u003C\u003E9__16_0 ?? (AmqpSender.\u003C\u003Ec.\u003C\u003E9__16_0 =
									new Func<AmqpSender, CreateMessageBatchOptions, TimeSpan, CancellationToken, Task<TransportMessageBatch>>(
										(object) AmqpSender.\u003C\u003Ec.\u003C\u003E9,
										__methodptr(\u003CCreateMessageBatchAsync\u003Eb__16_0))),
										t1,
										this.options,
										(TransportConnectionScope) t1._connectionScope,
										this.cancellationToken).ConfigureAwait(false).GetAwaiter();
							// rest omitted
						}
						</script></code></pre>
					<medium class="code-header">Remove closure allocations.</smmediumall>
						<aside class="notes">
							With that small change, we save the display class and the function delegate allocations and
							can
							properly usage methods that support value tasks without having to allocate a task instance
							when
							not necessary.
						</aside>
				</section>
				<section data-visibility="hidden">
					<pre class="fit" style="font-size: 0.9em"><code class="language-csharp" data-line-numbers="|7-9" data-trim data-noescape><script type="text/template">
						var someState = new object();
						var someOtherState = 42;

						var dictionary = new ConcurrentDictionary<string, string>();

						dictionary.GetOrAdd("SomeKey", (key) => 
						{
							return $"{someState}_{someOtherState}";
						});
						</script></code></pre>
					<medium class="code-header">Remove closure allocations.</medium>
				</section>
				<section data-visibility="hidden">
					<pre class="" style="font-size: 0.8em"><code class="language-csharp" data-line-numbers="|1,6" data-trim data-noescape><script type="text/template">
						<>c__DisplayClass0_0 <>c__DisplayClass0_ = new <>c__DisplayClass0_0();
						<>c__DisplayClass0_.someState = new object();
						<>c__DisplayClass0_.someOtherState = 42;
						
						concurrentDictionary.GetOrAdd("SomeKey", 
							new Func<string, string>(<>c__DisplayClass0_.<<Main>$>b__0));
						</script></code></pre>
					<medium class="code-header">Remove closure allocations.</smmediumall>
				</section>
				<section data-visibility="hidden">
					<pre class="fit" style="font-size: 0.9em"><code class="language-csharp" data-line-numbers="|3|5,8" data-trim data-noescape><script type="text/template">
						// same as before

						dictionary.GetOrAdd("SomeKey", static (key, state) => 
						{
							var (someState, someOtherState) = state;

							return $"{someState}_{someOtherState}";
						}, (someState, someOtherState));
						</script></code></pre>
					<medium class="code-header">Remove closure allocations.</medium>
					<aside class="notes">
						<ul>
							<li>Switch to ValueTask because some operations returned value tasks</li>
							<li>Use CSharp 9 static lambda features to make it impossible to access state within the
								delegate that is outside</li>
							<li>Use the state argument to pass in the state from the method including the operation as a
								value tuple into the function</li>
							<li>Deconstruct the value tuple and execute the operation passing all necessary state to it.
							</li>
						</ul>
					</aside>
				</section>
				<section data-visibility="hidden">
					<pre class="" style="font-size: 0.65em"><code class="language-csharp" data-line-numbers="|5" data-trim data-noescape><script type="text/template">
						object item = new object();
						int item2 = 42;

						concurrentDictionary.GetOrAdd("SomeKey", 
							<>c.<>9__0_0 ?? (<>c.<>9__0_0 = 
								new Func<string, ValueTuple<object, int>, string>(<>c.<>9.<<Main>$>b__0_0)), 
									new ValueTuple<object, int>(item, item2));
						</script></code></pre>
					<medium class="code-header">Remove closure allocations.</smmediumall>
				</section>
				<section data-visibility="hidden" data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section data-visibility="hidden" data-background="benchmarks/ConcurrentDictionaryGetOrAdd.png"
					data-background-size="95%">
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:17%; top:35%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 50px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~71%<br />
								<i class="fa fa-trash-o"></i> ~Gone!
							</p>
						</div>
					</div>
				</section>
				<section>
					<h2 class="r-fit-text" data-id="thumb">How to detect those allocations?</h2>
					<ul>
						<li class="fragment fade-in">Use memory profilers and watch out for excessive allocations of
							<code>*__DisplayClass*</code> or various variants of <code>Action*</code> and
							<code>Func*</code>
						</li>
						<li class="fragment fade-in">Use tools like <a
								href="https://plugins.jetbrains.com/plugin/9223-heap-allocations-viewer">Heap Allocation
								Viewer (Rider)</a> or <a
								href="https://marketplace.visualstudio.com/items?itemName=MukulSabharwal.ClrHeapAllocationAnalyzer">Heap
								Allocation Analyzer (Visual Studio)</a></li>
						<li class="fragment fade-in">Many built-in .NET types that use delegates have nowadays generic
							overloads that allow to pass state into the delegate.</li>
					</ul>
					<aside class="notes">
						To demonstrate how these can add up in real-world scenarios, let me show you a before and
						after
						comparison when I removed the closure allocations for NServiceBus pipeline execution
					</aside>
				</section>
				<section>
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:20%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 50px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~74-78%<br />
								<i class="fa fa-trash-o"></i> ~Gone!
							</p>
						</div>
						<img src="benchmarks/NServiceBusPipelineExecutionCropped.png" />
						<p style="font-size: 1.5em"><a
								href="https://go.particular.net/ndc-oslo-2023-pipeline">go.particular.net/ndc-oslo-2023-pipeline</a>
						</p>
					</div>
				</section>
			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none;">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Pool and re-use buffers (and larger objects)</p>
					</div>
				</section>
				<section>
					<pre class="fit" style="font-size: 0.9em"><code class="language-csharp" data-line-numbers="|3,4" data-trim data-noescape><script type="text/template">
						var data = new ArraySegment<byte>(Guid.NewGuid().ToByteArray());

						var guidBuffer = new byte[16];
						Buffer.BlockCopy(data.Array, data.Offset, guidBuffer, 0, 16);
						var lockTokenGuid = new Guid(guidBuffer);
						</script></code></pre>
					<medium class="code-header">Pool and re-use buffers.</medium>
					<aside class="notes">
						Azure Service Bus uses the concept of lock tokens (a glorified GUID) in certain modes to
						acknowledge messages. For messages loaded by the client, there is a lock token that needs to be
						turned into a GUID representation. When receiving lots of messages this creates countless
						unnecessary allocations.
					</aside>
				</section>
				<section>
					<pre class="fit" style="font-size: 0.9em"><code class="language-csharp" data-line-numbers="|1|4" data-trim data-noescape><script type="text/template">
						byte[] guidBuffer =  ArrayPool<byte>.Shared.Rent(16);
						Buffer.BlockCopy(data.Array, data.Offset, guidBuffer, 0, 16);
						var lockTokenGuid = new Guid(guidBuffer);
						ArrayPool<byte>.Shared.Return(guidBuffer);
						</script></code></pre>
					<medium class="code-header">Pool and re-use buffers.</medium>
					<aside class="notes">
						.NET has a built-in mechanism called ArrayPool&lt;T&gt; that allows to have pooled arrays that
						can be
						reused.
					</aside>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section data-background="benchmarks/BufferAndBlockCopyPooling.png" data-background-size="90%">
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:-10%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(168, 114, 33, 0.9); color: #fff; padding: 25px; font-size: 50px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> +226%<br />
								<i class="fa fa-trash-o"></i> ~Gone!
							</p>
						</div>
					</div>
					<aside class="notes">
						It turns out while we are saving allocations now we haven't really made things much better
						overall since the code now takes more than double the time to execute. It might very well be
						that this is an acceptable tradeoff for library or framework you are building. That being said,
						we can do better.
					</aside>
				</section>
			</section>
			<section>
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>For smaller local buffers, consider using the stack</p>
					</div>
				</section>
				<section>
					<pre class="fit" style="font-size: 0.9em"><code class="language-csharp" data-line-numbers="|1|2" data-trim data-noescape><script type="text/template">
						Span<byte> guidBytes = stackalloc byte[16];
						data.AsSpan().CopyTo(guidBytes);
						var lockTokenGuid = new Guid(guidBytes);
						</script></code></pre>
					<medium class="code-header">Small local buffers on stack.</medium>
					<aside class="notes">
						With the introduction of Span&lt;T&gt; and the stackalloc keyword, we can directly allocate the
						memory on the method's stack that is cleared when the method returns. But why even copying when
						Guid ctors have support for ReadOnlySpan&lt;T&gt;? Due to having to target .NET Standard 2.0, where we can only pass `byte[]` to the Guid constructor and we have to take endianness into account, the actual version was a bit more complicated and the above example is slightly twisting the reality, call it artistic freedom. We will be talking about techniques of how to
						avoid
						memory copying later. Where you have to copy memory though this technique comes in handy.
					</aside>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section data-background="benchmarks/StackallocWithGuid.png" data-background-size="90%">
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:20%; top:-10%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 50px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~45%<br />
								<i class="fa fa-trash-o"></i> ~Gone!
							</p>
						</div>
					</div>
					<aside class="notes">
						Be ware to not overallocate on the stack. This can lead to nasty problems at runtime. When
						allocating a certain size sometimes it is better to also skip locals init. We will be talking
						about that later.
					</aside>
				</section>
			</section>
			<section data-visibility="hidden">
				<section data-background="img/excess-g121ed821c_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid excessive allocations to reduce the GC overhead</h2>
						<p>Parameter overloads and boxing</p>
					</div>
					<aside class="notes">
						Some methods have parameter overloads of type `params object[]`. That can lead to some sneaky
						and costly array allocations that you might not even be aware of. With never incarnations of
						.NET there have been a number of improvements done on that area by introducing new method
						overloads for common cases that don't require to allocate a parameter array.
					</aside>
				</section>
				<section data-auto-animate>
					<code data-id="whenany-title">Task.WhenAny</code>
					<pre data-id="whenany"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						public static Task<Task> WhenAny(params Task[] tasks);
						// most common case
						await Task.WhenAny(new[] { task1, task2 });
						</script></code></pre>
					<small class="code-header">Avoid parameter overloads and boxing.</small>
				</section>
				<section data-auto-animate>
					<code data-id="whenany-title">Task.WhenAny</code>
					<pre data-id="whenany"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						public static Task<Task> WhenAny(Task task1, Task task2);

						await Task.WhenAny(task1, task2);
						</script></code></pre>
					<small class="code-header">Avoid parameter overloads and boxing.</small>
				</section>
				<section data-auto-animate>
					<code>CancellationTokenSource</code>
					<pre data-id="tokensource" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						public static CancellationTokenSource CreateLinkedTokenSource(
							params CancellationToken[] tokens
						);
						</script></code></pre>
					<small class="code-header">Avoid parameter overloads and boxing.</small>
				</section>
				<section data-auto-animate>
					<code>CancellationTokenSource</code>
					<pre data-id="tokensource" style="font-size: 0.5em"><code class="language-csharp" data-line-numbers="" data-trim data-noescape><script type="text/template">
						public static CancellationTokenSource CreateLinkedTokenSource(
							CancellationToken token1,
							CancellationToken token2
						);
						</script></code></pre>
					<small class="code-header">Avoid parameter overloads and boxing.</small>
				</section>
			</section>
			<section data-background="img/office-4249395_1280.jpg">
			</section>
			<section>
				<ul>
					<li>Avoid excessive allocations to reduce the GC overhead</li>
					<ul>
						<li>Think at least twice before using LINQ or
							unnecessary enumeration on the hot path</li>
						<li>Be aware of closure allocations</li>
						<li>Pool and re-use buffers</li>
						<li>For smaller local buffers, consider using the stack</li>
						<li style="color: lightslategray">Be aware of parameter overloads</li>
						<li style="color: lightslategray">Where possible and feasible use value types but pay
							attention to unnecessary boxing</li>
						<li style="color: lightslategray">Move allocations away from the hot-path where possible</li>
					</ul>
				</ul>
			</section>
			<section data-background="img/plotter-2138990_1280.jpg">
				<div class="image-slide-box">
					<h2 style="text-transform: none">Avoid unnecessary copying of memory</h2>
				</div>
				<aside class="notes">
					<ul>
						<li>The key to avoid unnecessary copying is Span and friends introduced with CSharp 7.3</li>
						<li>Span&lt;T&gt; is a value type that enables the representation of contiguous regions of
							arbitrary memory</li>
						<li>It is a pointer to a memory location and a length to represent the length of the memory
							represented by the span.</li>
						<li>It can be "sliced" into various chunks, you can represent various slices of memory of
							variable length without having to copy the memory</li>
						<li>Span&lt;T&gt; can only live on the stack while its cousin Memory&lt;T&gt; can live on the
							heap and therefore be used in asynchronous methods.</li>
						<li>We want rules I know.</li>
					</ul>
				</aside>
			</section>
			<section data-visibility="hidden">
				<section data-background="img/plotter-2138990_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid unnecessary copying of memory</h2>
						<p>Watch out for immutable/readonly data that is copied</p>
					</div>
				</section>
				<section data-auto-animate>
					<pre data-id="body-copy" style="font-size: 0.45em"><code class="language-csharp" data-line-numbers="|11-12" data-trim data-noescape><script type="text/template">
						public class ServiceBusReceivedMessage {
							public BinaryData Body { get; }
						}

						public static ServiceBusMessage
							CreateFrom(ServiceBusReceivedMessage message) {
							//...
							var originalBody = message.Body;
							if (!originalBody.IsEmpty)
							{
								var clonedBody = new byte[originalBody.Length];
								Array.Copy(originalBody.ToArray(), clonedBody, originalBody.Length);
								copiedMessage.Body = clonedBody;
							}
						}
						</script></code></pre>
					<small class="code-header">Immutable/readonly data should not be copied.</small>
				</section>
				<section data-auto-animate>
					<pre data-id="body-copy" style="font-size: 0.45em"><code class="language-csharp" data-line-numbers="|11" data-trim data-noescape><script type="text/template">
						public class ServiceBusReceivedMessage {
							public BinaryData Body { get; }
						}

						public static ServiceBusMessage
							CreateFrom(ServiceBusReceivedMessage message) {
							//...
							var originalBody = message.Body;
							if (!originalBody.IsEmpty)
							{
								copiedMessage.Body = originalBody;
							}
						}
						</script></code></pre>
					<small class="code-header">Immutable/readonly data should not be copied.</small>
					<aside class="notes">
						Other times memory copying isn't so obvious or requires a deep understand of what is
						happening
						under the hoods of the framework, library or SDK in use.
					</aside>
				</section>
			</section>
			<section>
				<section data-background="img/plotter-2138990_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Avoid unnecessary copying of memory</h2>
						<ul>
							<li>Look for Stream and Byte-Array usages that are copied or manipulated without using
								<code>Span</code> or <code>Memory</code>
							</li>
							<li>Replace existing data manipulation methods with newer <code>Span</code> or
								<code>Memory</code> based variants
							</li>
						</ul>
					</div>
					<aside class="notes">
						<ul>
							<li>Other times memory copying isn't so obvious or requires a deep understand of what is
								happening
								under the hoods of the framework, library or SDK in use.</li>
							<li>The EventHubs client has recently introduced a new publisher type that uses internally a
								partition key resolver that turns string partition keys into hash codes. 30-40% of the
								hot path will be using partition keys when publishing, and therefore represents a
								non-trivial amount of CPU and memory cycles when using that publisher type. The hash
								code function looked like the following.</li>
						</ul>
					</aside>
				</section>
				<section>
					<pre class="stretch" data-id="compute-hash" style="font-size: 0.7em"><code class="language-csharp" data-line-numbers="|6,7,11" data-trim data-noescape><script type="text/template">
						private static short GenerateHashCode(string partitionKey) {
							if (partitionKey == null) {
								return 0;
							}

							var encoding = Encoding.UTF8;
							ComputeHash(encoding.GetBytes(partitionKey), 0, 0, out uint hash1, out uint hash2);
							return (short)(hash1 ^ hash2);
						}

						private static void ComputeHash(byte[] data, uint seed1, uint seed2,
							out uint hash1, out uint hash2)	{

							uint a, b, c;

							a = b = c = (uint)(0xdeadbeef + data.Length + seed1);
							c += seed2;

							int index = 0, size = data.Length;
							while (size > 12) {
								a += BitConverter.ToUInt32(data, index);
								b += BitConverter.ToUInt32(data, index + 4);
								c += BitConverter.ToUInt32(data, index + 8);

							// rest omitted
						}
						</script></code></pre>
					<medium class="code-header">Avoid unnecessary copying of memory.</medium>
				</section>
				<section>
					<pre class="stretch" data-id="compute-hash" style="font-size: 0.6em"><code class="language-csharp" data-line-numbers="|10|13|7,13-16|18-19|16,23-25|29|1,15" data-trim data-noescape><script type="text/template">
						[SkipLocalsInit]
						private static short GenerateHashCode(string partitionKey) {
							if (partitionKey == null) {
								return 0;
							}

							const int MaxStackLimit = 256;

							byte[] sharedBuffer = null;
							var partitionKeySpan = partitionKey.AsSpan();
							var encoding = Encoding.UTF8;

							var partitionKeyByteLength = encoding.GetMaxByteCount(partitionKey.Length);
							var hashBuffer = partitionKeyByteLength <= MaxStackLimit ?
								stackalloc byte[MaxStackLimit] :
								sharedBuffer = ArrayPool<byte>.Shared.Rent(partitionKeyByteLength);

							var written = encoding.GetBytes(partitionKeySpan, hashBuffer);
							var slicedBuffer = hashBuffer.Slice(0, written);

							ComputeHash(slicedBuffer, 0, 0, out uint hash1, out uint hash2);

							if (sharedBuffer != null) {
								ArrayPool<byte>.Shared.Return(sharedBuffer);
							}
							return (short)(hash1 ^ hash2);
						}

						private static void ComputeHash(ReadonlySpan<byte> data, uint seed1, uint seed2,
							out uint hash1, out uint hash2)	{
							// rest omitted
						}
						</script></code></pre>
					<medium class="code-header">Avoid unnecessary copying of memory.</medium>
					<aside class="notes">
						<ul>
							<li>GetMaxByteCount: This is more efficient than asking for the actual byte length of the
								string because it has O(1) semantics and doesn't traverse the whole string. So we
								overrent. That's fine.</li>
							<li>In cases when the byte length is longer than the maximum defined stack limit a regular
								byte array is rented from the ArrayPool. The allocated buffer is then passed to the
								encoding and then sliced before passing to the ComputeHash method into the corresponding
								memory area that was actually used</li>
							<li> At the end the when a buffer was pooled it is returned to the pool without clearing
								since the partition keys are not considered sensitive data.</li>
							<li>Also notice there is no finally block since we triaged it and couldn't come up with a
								scenario for valid Unicode strings GetBytes would be throwing</li>
						</ul>
					</aside>
				</section>
				<section data-background="img/time-g5afc932c4_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">Benchmarking Time!</h2>
						<p>We can only know the before and after when we measure it.</p>
					</div>
				</section>
				<section data-background="benchmarks/PartitionKeyResolver.png" data-background-size="60%">
					<div style="position:relative;">
						<div class="fragment fade-in"
							style="position: absolute; left:17%; top:35%; width: 60%; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(33, 168, 100, 0.9); color: #fff; padding: 25px; font-size: 50px; text-align: center;">
							<p><i class="fa fa-tachometer" aria-hidden="true"></i> ~38-47%<br />
								<i class="fa fa-trash-o"></i> ~Gone!
							</p>
						</div>
					</div>
				</section>
				<section data-background="img/office-4249395_1280.jpg">
				</section>
				<section>
					<ul class="r-fit-text">
						<li>Look for Stream and Byte-Array usages that are copied or
							manipulated without using
							<code>Span</code> or <code>Memory</code>
						</li>
						<li>Replace existing data manipulation methods with newer
							<code>Span</code> or
							<code>Memory</code> based variants
						</li>
						<li style="color: lightslategray">Watch out for immutable/readonly data that is copied</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<ul>
						<li>Avoid excessive allocations to reduce the GC overhead</li>
						<ul>
							<li>Be aware of closure allocations</li>
							<li>Think at least twice before using LINQ <br /> or
								unnecessary enumeration on the hot path</li>
							<ul>
								<li>Use <code>Array.Empty&lt;T&gt;</code> to represent empty arrays
								</li>
								<li>Use <code>Enumerable.Empty&lt;T&gt;</code> to represent empty
									enumerables</li>
								<li>Prevent collections from growing</li>
								<li>Use concrete collection types</li>
								<li>Leverage pattern matching or
									<code>Enumerable.TryGetNonEnumeratedCount</code>
								</li>
								<li>Wait with instantiating collections until really needed</li>
								<li>There be dragons</li>
								<ul>
									<li>Align access or use unsafe to avoid bound checks</li>
									<li>Use <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.collectionsmarshal">CollectionMarshal</a>/<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal">MemoryMarshal</a>/<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafe">Unsafe</a> to access the underlying data directly</li>
								</ul>
							</ul>
							<li>Pool and re-use buffers</li>
							<li>For smaller local buffers, consider using the stack</li>
							<li>Be aware of parameter overloads</li>
							<li>Where possible and feasible use value types but pay
								attention to unnecessary boxing</li>
							<li>Move allocations away from the hot-path where possible</li>
						</ul>
					</ul>
				</section>
				<section>
					<ul>
						<li>Avoid unnecessary copying of memory
							<ul>
								<li>Watch out for immutable/readonly data that is copied</li>
								<li>Look for Stream and Byte-Array usages that are copied or manipulated without using
									<code>Span</code> or <code>Memory</code>
								</li>
								<li>Replace existing data manipulation methods with newer <code>Span</code> or
									<code>Memory</code> based variants
								</li>
							</ul>
						</li>
					</ul>
				</section>
				<section data-background="img/quiz-2137664_1280.jpg">
					<div class="image-slide-box">
						<h2 style="text-transform: none">In case you are up for a challenge</h2>
						<p>The original <code style="color: lightskyblue;">ComputeHash</code> method had a <i
								class="fa fa-bug" aria-hidden="true" style="color: lightskyblue;"></i>.<br />Did you
							spot it?
						</p>
						<pre style="color: gray; font-size: 0.7em">static void ComputeHash(byte[] data, uint seed1, uint seed2,
	out uint hash1, out uint hash2)	{

   uint a, b, c;

   a = b = c = (uint)(0xdeadbeef + data.Length + seed1);
   c += seed2;

   int index = 0, size = data.Length;
   while (size > 12) {
      a += BitConverter.ToUInt32(data, index);
      b += BitConverter.ToUInt32(data, index + 4);
      c += BitConverter.ToUInt32(data, index + 8);

      // rest omitted
   }</pre>
					</div>

					<aside class="notes">
						Reach out to me over twitter or my email provided on the next slide.
					</aside>
				</section>
				<section data-background="img/science-1182713_1280.jpg">
					<div
						style="width: 70%; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.8); color: rgb(255, 255, 255); padding: 25px; font-size: 50px; text-align: left;">
						<h5>At Scale implementation details matter</h5>
						<div>
							<p><img src="img/repolink.svg" style="float: right; margin-top: auto;" />Tweak
								expensive I/O operations first. <br />Pay close attention to the context of the
								code.<br />
								Apply the principles where they matter. <br />Everywhere else, favor readability.
							</p>
							<p><a
									href="https://github.com/danielmarbach/PerformanceTricksAzureSDK">github.com/danielmarbach/PerformanceTricksAzureSDK</a>
							</p>
							<p>Happy coding!</p>

							<p style="font-size: 30px;">
								<i class="fa fa-twitter" aria-hidden="true"><a href="https://twitter.com/danielmarbach">
										danielmarbach</a></i>
								<i class="fa fa-envelope" aria-hidden="true"> <a
										href="mailto:&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#100;&#97;&#110;&#105;&#101;&#108;&#46;&#109;&#97;&#114;&#98;&#97;&#99;&#104;&#64;&#112;&#97;&#114;&#116;&#105;&#99;&#117;&#108;&#97;&#114;&#46;&#110;&#101;&#116;">&#100;&#97;&#110;&#105;&#101;&#108;&#46;&#109;&#97;&#114;&#98;&#97;&#99;&#104;&#64;&#112;&#97;&#114;&#116;&#105;&#99;&#117;&#108;&#97;&#114;&#46;&#110;&#101;&#116;</a></i>
							</p>

						</div>
					</div>
					<aside class="notes">
						<ul>
							<li>Tweak expensive I/O operations first</li>
							<li>Once that
								is done the principles and practices here can make your code even faster.</li>
							<li>Optimizations can also be efficiently combined with refactorings and redesigns on
								the hot path.</li>
							<li>8% increase in overall publishing throughout for the last Event Hubs release, and like a
								3-4% for the processor.</li>
							<li>For us, as engineers, it means we have to know what to ignore and knowing what to pay
								close
								attention to in the code base we are working. And sometimes that will mean ignoring the
								performance optimizations learned here in the code bases they don't matter, yet
								consistently
								applying them where they do.</li>
							<li>The readme also contains to longer recordings from online versions of this talk.</li>
						</ul>
					</aside>
				</section>
			</section>

		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/search/search.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			controls: true,
			progress: true,
			hash: true,

			width: 1920,
			height: 1080,

			margin: 0.1,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
		});
	</script>
</body>

</html>